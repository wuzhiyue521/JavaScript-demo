/**
 * 1. 第三章 - 作用域和闭包:
 *
 * 1. 闭包
 */

/**
 * 1. 闭包的使用场景:
 *    1. 函数作为返回值 。
 *    2. 函数作为参数传递 。
 */


/**
 * 1. 函数作为返回值:
 *
 * 1. 执行:
 *    1. fn1() 执行的时候执行的是 Fn1() 中的 return 的函数, console.log(a) 的时候 a 是一个 自由变量, 自由变量 我们要去父级里面去找, 父级作用域怎么找, 哪个作用域定义了它, 即 Fn1(); a 向上找就是 var a = 100, var a = 200 全局变量与 Fn1() 中的 var a = 100 完全是两码事, 两者毫无关系, 所以全局变量 var a = 200 对 Fn1() 中的 var a = 100 毫无影响。
 *
 * 2. 一个函数的父级作用域是它定义时候的作用域, 而不是它执行时候的作用域; return 的这个函数是 Fn1() 作用域定义的; 这就是 闭包的一个体现 。
 */
function Fn1() {
  var a = 100;
  // 返回一个函数, 函数作为返回值 。
  return function () {
    console.log(a); // a 自由变量, 向父级作用域去寻找(函数定义的时候去寻找; 函数定义时的父作用域)。
  }
}
// fn1 得到一个函数。
var fn1 = Fn1();
var a = 200; // 注意: 不要误以为, 向函数执行的时候去寻找 。
fn1() // 打印结果: 100
// *************************************
function Fn2() {
  // var a = 100;
  // 返回一个函数, 函数作为返回值 。
  return function () {
    console.log(a);
  }
}
// fn2 得到一个函数。
var fn2 = Fn2();
var a = 200;
fn2() // 打印结果: 200



/**
 * 2. 函数作为参数传递:
 */
function Fn3() {
  var a = 111;
  return function () {
    console.log(a);
  }
}
var fn3 = Fn3();
function Fn4(fn) {
  var a = 999
  fn(); // 执行这个 fn() 的时候其实就是执行 Fn3() 函数中的 return 的函数, return 函数中的 a 也是一个自由变量, 自由变量 就需要去向父作用域里面去寻找, 要向函数定义时的父作用域里面去寻找, 即 Fn3() 函数中去寻找 var a = 111, 不要在函数执行的时候去寻找, 否则就会得到错误的结果 999 。
}
Fn4(fn3) // 打印结果: 111